#!/usr/bin/env bash

####################################################################
# Get state of the pipe (not only the last command)
# DON'T CHANGE
####################################################################
set -o pipefail
set -u
#set -e

####################################################################
# Configuration parameters
####################################################################
declare -r version="0.1"
declare -r TMPBASIC="/dev/shm/sync-"

####################################################################
# Usage: log [LOGLEVEL] MESSAGE
# Logging function:
#+ save MESSAGE in a logfile
#+ exit with exit status 1, if LOGLEVEL is error
#+ write to stderr on LOGLEVEL error
# LOGLEVEL: info (default), warning, error
# Returns: No return state, exit on LOGLEVEL error
####################################################################
function log() {
	# Check Parameters and set it, if correct
	if [[ $# -eq 1 ]]; then
		if [[ $1 = "error" ]]; then
			loglevel="$1"
			message="$(<$ERRMSG)"
		else 
			loglevel="info"
			message="$1"
		fi
	elif [[ $# -eq 2 ]]; then
		loglevel=$1
		message=$2
	else
		loglevel="error"
		message="Wrong number of arguments on calling function log"
	fi

	# Tranform LOGLEVEL to Text (for log-message)
	case $loglevel in
		error)
			loglevel_txt="Error"
			;;
		warning)
			loglevel_txt="Warning"
			;;
		info)
			loglevel_txt="Info"
			;;
		*)
			log error "\"$loglevel\" is not an correct loglevel"
			return
			;;
	esac

	# Create log-message
	log_message=$(echo -e "$(date +"%Y%m%d_%H:%M:%S") $loglevel_txt ${FUNCNAME[1]}, ${BASH_LINENO[0]}: $message")

	# Write to log-message to logfile
	echo "$log_message" >> sync.log

	# Write MESSAGE to stderr if LOGLEVEL is error and exit with exit status 1
	if [[ "$loglevel" = "error" ]]; then
		# Restore stderr to print message
		exec 2<&5	# restore standard error
		exec 5>&-	# close file descriptor to redirected stderr
		# Output $message to stderr
		echo "$message" 1>&2
		exit 1
	fi
}

####################################################################
# Usage: on_exit
# Run all saved commands for exit programm
# Returns: No return state
####################################################################
function on_exit() {
	for i in "${on_exit_items[@]}"
	do
		log info "Run on_exit command: \"$i\""
		eval "$i"
	done
}

####################################################################
# Usage: add_on_exit
# Add command to variable on_exit_items
# Returns: No return state
####################################################################
function add_on_exit() {
	# Add parameters to array
	log info "add exit item \"$*\""
    on_exit_items[${#on_exit_items[@]}]="$*"
}

####################################################################
# Usage: get_sql_data TYPE PATH
# Read data from SQL-File and write in the correct format
# TYPE: Has to be "files" or "folders"
# PATH: Path to the SQL-File
# Returns: No return state
####################################################################
function get_sql_data() {
	# Run logging on error (exit programm)
	trap "log error" ERR
	
	local type="$1"
	local db_file="$2"
	
	# Get all files from database and convert to format
	sqlite3 -separator $'\t' $db_file "SELECT rights, moddate, path || x'00' FROM $type" | sed -z 's/[\n\x00]/\x00/g'
}

####################################################################
# Usage: check_changes TYPE PATH DB_LIST
# Read files from PATH and compare it to the list from SQL
# TYPE: Has to be "files" or "folders"
# PATH: Path to check
# DB_LIST: List from the SQL (see function get_sql_data)
# Returns: Files who diffrent to SQL-List
####################################################################
function check_changes() {
	# Run logging on error (exit programm)
	trap "log error" ERR
	
	local type="$1"
	local path="$2"
	local db_list="$3"
	
	# Check if PATHs exists
	if [[ ! -e "$path" ]]; then
		log error "folder \"$path\" could not found"
	fi
	
	# convert variable type to the shortname for find
	if [[ $type == "files" ]]; then
		type="f"
	elif [[ $type == "folders" ]]; then
		type="d"
	else
		log error "Wrong TYPE \"$type\" on calling function \"check_changes\""
	fi
	
	# Save filelist to $TMPFILE
	log info "Read files from path \"$path\""

	# Create filter to remove path from filename
	path_filter="$(echo $path | sed 's/\//\\\//g')"
	# Find files and remove path from filename using $filter
	# -mindepth 1 is used to not check the path itself. Just underlying files and folders
	find "$path" -type $type -mindepth 1 -printf "%m\t%T@\t%p\0" |
	sed -z "s/$path_filter//g" > "$TMPFILE"
	
	# Find changed files
	# sort: sort filelist from $TMPFILE and $db_list
	# unique: remove unchanged files (fs and sql file is the same)
	# sed: remove additional information (just get the path)
	# unique: remove double filenames (show path only once)
	sort -z "$TMPFILE" "$db_list" |
	uniq -z -u |
	sed -z 's/^.*[\t]//g' |
	sort -z |
	uniq -z
}

####################################################################
# Usage: copy_and_update_file SOURCE_PATH TARGET_PATH
# Create or copy the file from source to target and update the
#+ modification date and rights
# SOURCE_PATH: Full path to source
# TARGET_PATH: Full path to target
# Returns: No return state
####################################################################
function copy_and_update_file() {
	# Run logging on error (exit programm)
	trap "log error" ERR
	
	local source_path="$1"
	local target_path="$2"
	
	# If Â§source_path is a folder, don't copy
	if [[ -d "$source_path" ]]; then
		# if $target_path exist, don't create a new one
		if [[ ! -e "$target_path" ]]; then
			mkdir "$target_path"
		fi
	else
		cp "$source_path" "$target_path"
	fi
	
	# Update file properties
	update_file "$source_path" "$target_path"
}


####################################################################
# Usage: copy_and_update_file SOURCE_PATH TARGET_PATH
# Change the modification date and rights from target to the same
#+ like source
# SOURCE_PATH: Full path to source
# TARGET_PATH: Full path to target
# Returns: No return state
####################################################################
function update_file() {
	# Run logging on error (exit programm)
	trap "log error" ERR
	
	local source_path="$1"
	local target_path="$2"
	
	touch -m -r "$source_path" "$target_path"
	chmod --reference="$source_path" "$target_path"
}

####################################################################
# Usage: do_action TYPE PATH
# Check which action is needed and do it
# TYPE: Has to be "files" or "folders"
# PATH: sub-path to file or directory
# Returns: No return state
####################################################################
function do_action() {
	# Run logging on error (exit programm)
	trap "log error" ERR
	
	# declare path
	local type="$1"
	local path="$2"
	local path1_full="$path1$path"
	local path2_full="$path2$path"
	
	# check if path is in sql
	local -i x=$(sqlite3 $config_db "SELECT count(*) FROM $type WHERE path=\"$path\"")

	if [[ $x -eq 0 ]]; then
		# File don't exists in sql
		if [[ -e "$path1_full" ]]; then
			log info "File \"$path1_full\" is new and get copied to \"$path2_full\""
			copy_and_update_file "$path1_full" "$path2_full"
		else
			log info "File \"$path2_full\" is new and get copied to \"$path1_full\""
			copy_and_update_file "$path2_full" "$path1_full"
		fi
		# Insert file with information to sql
		local moddate="$(find "$path1_full" -maxdepth 0 -printf "%T@")"
		local rights="$(find "$path1_full" -maxdepth 0 -printf "%m")"
		sqlite3 "$config_db" "INSERT INTO $type (path, moddate, rights) VALUES (\"$path\", \"$moddate\", \"$rights\")"
	else
		if [[ ! -e "$path1_full" ]]; then
			log info "File \"$path1_full\" deleted"
			rm -rf "$path2_full"
			sqlite3 $config_db "DELETE FROM $type WHERE path=\"$path\""
		elif [[ ! -e "$path2_full" ]]; then
			log info "File \"$path2_full\" deleted"
			rm -rf "$path1_full"
			sqlite3 $config_db "DELETE FROM $type WHERE path=\"$path\""
		else
			if [[ "$path1_full" -nt "$path2_full" ]]; then
				log info "File \"$path1_full\" updated"
				copy_and_update_file "$path1_full" "$path2_full"
			elif [[ "$path2_full" -nt "$path1_full" ]]; then
				log info "File \"$path2_full\" updated"
				copy_and_update_file "$path2_full" "$path1_full"
			else
				log info "File \"$path\" has changed rights."
				local -i rights=$(sqlite3 $config_db "SELECT rights FROM $type WHERE path=\"$path\"")
				if [[ $rights -ne $(stat -c %a "$path1_full") ]]; then
					update_file "$path1_full" "$path2_full"
				else
					update_file "$path2_full" "$path1_full"
				fi
			fi
			# Update file information on sql
			local moddate="$(find "$path1_full" -maxdepth 0 -printf "%T@")"
			local rights="$(find "$path1_full" -maxdepth 0 -printf "%m")"
			sqlite3 "$config_db" "UPDATE $type SET moddate=\"$moddate\", rights=\"$rights\" WHERE path=\"$path\""
		fi	
	fi
}

####################################################################
# Usage: add_slash PATH
# Add a / to the end of the path if dosn't exist
# PATH: Path to a folder
# Returns: Path with ending /
####################################################################
function add_slash() {
	# Run logging on error (exit programm)
	trap "log error" ERR
	
	local path="$1"

	# If PATH is a symlink folder, the last char must be a "/"
	# Check if last char is a "/". If not, add a "/"
	if [[ ${path:(-1)} != "/" ]]; then
		log info "Add / to path: "$path""
		path="${path}/"
	fi
	
	echo "$path"
}

####################################################################
# Start main programm
####################################################################
declare -a on_exit_items
declare -r TMPFILE="${TMPBASIC}tmp"; add_on_exit "rm -rf $TMPFILE"
declare -r ERRMSG="${TMPBASIC}err"; add_on_exit "rm -rf $ERRMSG"

# redirect all output from stderr for logging
exec 5<&2		# associate standard error (fd2) with file descriptor 5 (save for later)
exec 2>"$ERRMSG"	# redirect standard error to $ERR (used for logging with function log)

# Run logging on error (exit programm)
trap "log error" ERR

# Run all commands from array $on_exit_items on program exit
trap "on_exit" EXIT

# Check if enough arguments set or help should show
if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
	echo "Usage: $0 [OPTION] NAME"
	echo "OPTION:"
	echo "	--create	create a new config"
	echo "	--delete	delete a existing config"
	exit 1
fi

# Set Options
if [[ $1 == "--create" || $1 == "--delete" ]]; then
	declare -r config_name="$2"
else
	declare -r config_name="$1"
fi
declare -r config_db="$HOME/.sync/$config_name"

# Create new config
if [[ $1 == "--create" ]]; then
	# Check if config still exists
	if [[ -e "$config_db" ]]; then
		log error "Config: \"$config_name\" exists"
	fi
	
	# Get paths from user input
	while true; do
		echo "Insert first path for sync:"
		read path1
		if [[ -d "$path1" ]]; then
			path1="$(add_slash $path1)"
			break
		fi
		echo "Folder: \"$path1\" did not exist"
	done
	
	while true; do
		echo "Insert second path for sync:"
		read path2
		if [[ -d "$path2" ]]; then
			path2="$(add_slash $path2)"
			break
		fi
		echo "Folder: \"$path2\" did not exist"
	done

	# Create database and tables
	sqlite3 "$config_db" "CREATE TABLE config (version numeric, path1 text, path2 text);
						  CREATE TABLE files (path text primary key, moddate text, rights text);
						  CREATE TABLE folders (path text primary key, moddate text, rights text);"
	sqlite3 "$config_db" "INSERT INTO config (version, path1, path2) VALUES (0.1, \"$path1\", \"$path2\")"
	
	echo "Config \"$config_name\" sucessfully created"
	exit
fi

# Check if database with config exists
if [[ ! -e "$config_db" ]]; then
	log error "Config: \"$config_name\" did not exist"
fi

# Delete existing config
if [[ $1 == "--delete" ]]; then
	rm -rf "$config_db"
	exit
fi

# Create temporary files and add file deletion to on_exit_items
declare -r sql_data="${TMPBASIC}sql"; add_on_exit "rm -rf $sql_data"
declare -r path1_updated="${TMPBASIC}path1_updated"; add_on_exit "rm -rf $path1_updated"
declare -r path2_updated="${TMPBASIC}path2_updated"; add_on_exit "rm -rf $path2_updated"
declare -r conflicts="${TMPBASIC}conflicts"; add_on_exit "rm -rf $conflicts"
declare -r no_conflicts="${TMPBASIC}no_conflicts"; add_on_exit "rm -rf $no_conflicts"

# Read paths from sql
declare -r path1="$(sqlite3 $config_db "SELECT path1 FROM config")"
declare -r path2="$(sqlite3 $config_db "SELECT path2 FROM config")"

# Run two times. First time check and sync folders, second time check and sync files
for type in "folders" "files"; do
	# Read files from sql
	get_sql_data "$type" $config_db > $sql_data

	# Read files from filesystem and compare to files from sql
	check_changes "$type" "$path1" "$sql_data" > "$path1_updated"
	check_changes "$type" "$path2" "$sql_data" > "$path2_updated"

	# Save conflicts (file changed on booth paths)
	sort -z "$path1_updated" "$path2_updated" | uniq -zd > $conflicts

	# Save paths without conflicts
	sort -z "$path1_updated" "$path2_updated" | uniq -zu > $no_conflicts

	# Update files without conflicts
	while IFS= read -r -d $'\0' filename; do
		do_action "$type" "$filename"
	done < "$no_conflicts"

	# TODO: solve conflicts, check if file is the same
	# Update files without conflicts
	while IFS= read -r -d $'\0' filename; do
		echo "There are some conflicts on the following folder: \"$filename\". Can't solved at the moment."
	done < "$conflicts"
done
